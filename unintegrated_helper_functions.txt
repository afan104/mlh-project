
# # GRAVITATE MOUSE TOWARD CLICKABLE ITEMS (NOT INTEGRATED)
#     # launch google
#     mainGoogle = 'https://www.google.com/'
#     driver = webdriver.Chrome()
#     driver.maximize_window()
#     driver.get(mainGoogle)

#     scannedElements = getClickableElements(driver )
#     scanFlag = False
#     xPixel, yPixel = weight_elements(xPixel, yPixel, scannedElements)

# def getClickableElements(driver):
    # Get all button and anchor (link) elements
#     buttons = driver.find_elements(By.CSS_SELECTOR, 'button, a')
#     searchbars= driver.find_elements(By.NAME, 'q')
#     buttons.extend(searchbars)
#     elements = []
#     for button in buttons:
#         if button.is_displayed():  # Only consider visible buttons
#             location = button.location  # Get the top-left coordinates of the element
#             size = button.size  # Get the width and height of the element

#             # Calculate the center coordinates
#             center_x = location['x'] + size['width'] / 2
#             center_y = location['y'] + size['height'] / 2
#             elements.append([center_x, center_y])

#             print(f"Clickable element: {button.text}, Center: ({center_x}, {center_y})")
#     return elements


# def calculate_distance(point1, point2):
#     return np.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)

# # Function to weight elements by proximity
# def weight_elements(gaze_x, gaze_y, elements, snap_threshold=120, weight_exponent=6):
#     gaze_point = (gaze_x, gaze_y)

#     # Calculate distance from current gaze point to the elements on screen 
#     distances = []
#     for index, element in enumerate(elements):
#         dist = calculate_distance(gaze_point, element)
#         distances.append((index, dist))

#     # Sort clickable elements by distance from gaze point
#     distances = sorted(distances, key=lambda tup: tup[1])

#     # Apply weights based on proximity
#     total_weight = 0
#     weighted_position = np.array([0.0, 0.0])

#     for element, distance in distances:
#         if distance < snap_threshold:
#             weight = (snap_threshold - distance) ** weight_exponent
#             weighted_position += np.array(elements[element]) * weight
#             total_weight += weight

#     # Return weighted average position if within threshold
#     if total_weight > 0:
#         return weighted_position / total_weight
#     else:
#         return gaze_point  # Return original gaze point if no snapping
